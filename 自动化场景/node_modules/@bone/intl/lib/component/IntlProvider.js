'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _core = require('../core');

var _util = require('../util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// use global locale & messages when corresponding props are not provided
var dispatchers = [];
var globalLocale = 'zh';
var globalMessages = {};

/**
 * @params {String} [changedPropName] identify which global prop changed
 * */
var dispatchGlobal = function dispatchGlobal(changedPropName) {
  return dispatchers.forEach(function (dispatch) {
    return dispatch(changedPropName);
  });
};

var IntlProvider = function (_Component) {
  _inherits(IntlProvider, _Component);

  _createClass(IntlProvider, null, [{
    key: 'locale',
    set: function set(locale) {
      (0, _invariant2.default)(typeof locale === 'string', 'Expected locale to be a string');
      // make sure locale is indeed changed
      if (globalLocale !== locale) {
        globalLocale = locale;
        dispatchGlobal('locale');
      }
    },
    get: function get() {
      return globalLocale;
    }
  }, {
    key: 'messages',
    set: function set(messages) {
      (0, _invariant2.default)((0, _util.isPlainObject)(messages), 'Expected messages to be a plain object');
      // make sure messages is indeed changed
      if (!_immutable2.default.is(_immutable2.default.fromJS(globalMessages), _immutable2.default.fromJS(messages))) {
        globalMessages = messages;
        dispatchGlobal('messages');
      }
    },
    get: function get() {
      return globalMessages;
    }
  }]);

  function IntlProvider(props, context) {
    _classCallCheck(this, IntlProvider);

    var _this = _possibleConstructorReturn(this, (IntlProvider.__proto__ || Object.getPrototypeOf(IntlProvider)).call(this, props, context));

    _this.dispatch = function (changedPropName) {
      // if changed global prop is defined in props, won't be effective
      if (changedPropName in _this.props) {
        return;
      }
      _this.intl.dispatch(_this.getIntlInfo(_this.props));
    };

    var _this$getIntlInfo = _this.getIntlInfo(props),
        locale = _this$getIntlInfo.locale,
        messages = _this$getIntlInfo.messages;

    _this.intl = (0, _core.createIntl)(locale, messages);
    dispatchers.push(_this.dispatch);
    return _this;
  }

  _createClass(IntlProvider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      var _intl = this.intl,
          getMessage = _intl.getMessage,
          subscribe = _intl.subscribe,
          dispatch = _intl.dispatch;

      return {
        intl: { getMessage: getMessage, subscribe: subscribe, dispatch: dispatch }
      };
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if ('locale' in nextProps || 'messages' in nextProps) {
        var _getIntlInfo = this.getIntlInfo(this.props),
            prevLocale = _getIntlInfo.locale,
            prevMessages = _getIntlInfo.messages;

        var _getIntlInfo2 = this.getIntlInfo(nextProps),
            locale = _getIntlInfo2.locale,
            messages = _getIntlInfo2.messages;

        if (prevLocale !== locale || !_immutable2.default.is(_immutable2.default.fromJS(prevMessages), _immutable2.default.fromJS(messages))) {
          this.intl.dispatch({ locale: locale, messages: messages });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var index = dispatchers.indexOf(this.dispatch);
      if (index !== -1) {
        dispatchers.splice(index, 1);
      }
    }
  }, {
    key: 'getIntlInfo',
    value: function getIntlInfo(props) {
      var locale = void 0,
          messages = void 0;

      if ('locale' in props) {
        locale = props.locale;
      } else {
        locale = globalLocale;
      }

      if ('messages' in props) {
        messages = props.messages;
      } else {
        messages = globalMessages;
      }

      return { locale: locale, messages: messages };
    }

    // used by global intl info change

  }, {
    key: 'render',
    value: function render() {
      return _react.Children.only(this.props.children);
    }
  }]);

  return IntlProvider;
}(_react.Component);

IntlProvider.propTypes = {
  locale: _propTypes2.default.string,
  messages: _propTypes2.default.object,
  children: _propTypes2.default.element.isRequired
};
IntlProvider.childContextTypes = {
  intl: _core.intlShape
};
exports.default = IntlProvider;